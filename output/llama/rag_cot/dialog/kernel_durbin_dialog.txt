=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
G[k] =

X
n=0

g[2n] · e

−j2πkn
N/2

N/2−1

+

X
n=0

103

g[2n + 1] · e

−j2πk(2n)
N

·e

−j2πk
N

(5.15)

FAST FOURIER TRANSFORM

In the first summation (even inputs), we simply move the 2 into the denominator so that it is
now N/2. The second summation (odd inputs) uses the power rule to separate the +1 leaving two
complex exponentials. We can further modify this equation to
N/2−1

G[k] =

X

N/2−1

−j2πkn

g[2n] · e N/2 + e

−j2πk
N

·

n=0

X

−j2πkn

g[2n + 1] · e N/2

(5.16)

n=0

Here we only modify the second summation. First we pull one of the complex exponentials outside
of the summation since it does not depend upon n. And we also move the 2 into the denominator
as we did before in the first summation. Note that both summations now have the same complex
−j2πkn

exponential e N/2 . Finally, we simplify this to
G[k] = Ak + WNk Bk

(5.17)

Example 2: 
n−1
Y

Ki =

i=0

n−1
Y
i=0

√

1
1 + 2−2i

(3.24)

and
K = lim K(n) ≈ 0.6072529350088812561694
n→∞

(3.25)

The scaling factors for different iterations can be calculated in advance and stored in a table. If we
always perform a fixed number of rotations, this is simply one constant. This correction could also
be made in advance by scaling v0 appropriately before performing the rotations. Sometimes it is
ok to ignore this scaling, which results in a processing gain
n−1

A=

Yp
1
= lim
1 + 2−2i ≈ 1.64676025812107
n→∞
K

(3.26)

i=0

Example 3: 
for (i = N − 1; i > 0; i−−) {
shift reg[i] = shift reg[i − 1];
}
shift reg[0] = x;
acc = 0;
MAC:

Optimize the following code by inserting pragma HLS lines. Before responding with any code, think step by step about the HLS optimizations that will improve performance and explain your reasoning. Finally, generate the C code with pragma HLS.

void kernel_durbin(int n,float r[120],float y[120])
{
  float z[120];
  float alpha;
  float beta;
  float sum;
  int i;
  int k;
{
    y[0] = -r[0];
    beta = 1.0;
    alpha = -r[0];
    
    
    
    for (k = 1; k < 120; k++) {
      beta = (((float )1) - alpha * alpha) * beta;
      sum = 0.0;
      for (i = 0; i < k; i++) {
        sum += r[k - i - 1] * y[i];
      }
      alpha = -(r[k] + sum) / beta;
      for (i = 0; i < k; i++) {
        z[i] = y[i] + alpha * y[k - i - 1];
      }
      for (i = 0; i < k; i++) {
        y[i] = z[i];
      }
      y[k] = alpha;
    }
  }
}


=== LLAMA RESPONSE ===
Here's the optimized code with HLS pragmas:

```c
#include <ap_fixed.h>
#include <ap_int.h>

void kernel_durbin(int n, float r[120], float y[120]) {
  #pragma HLS INTERFACE m_axi port=r offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=y offset=slave bundle=gmem
  #pragma HLS INTERFACE s_axilite port=n bundle=control
  #pragma HLS INTERFACE s_axilite port=return bundle=control
  #pragma HLS INTERFACE s_axilite port=r[0] bundle=control
  #pragma HLS INTERFACE s_axilite port=y[0] bundle=control

  float z[120];
  float alpha;
  float beta;
  float sum;
  int i;
  int k;

  #pragma HLS DATAFLOW
  #pragma HLS pipeline II=1

  y[0] = -r[0];
  beta = 1.0;
  alpha = -r[0];

  #pragma HLS LOOP_TRIPCOUNT min=1 max=119
  #pragma HLS UNROLL
  for (k = 1; k < 120; k++) {
    beta = (((float)1) - alpha * alpha) * beta;
    sum = 0.0;
    #pragma HLS LOOP_TRIPCOUNT min=1 max=k-1
    #pragma HLS UNROLL
    for (i = 0; i < k; i++) {
      sum += r[k - i - 1] * y[i];
    }
    alpha = -(r[k] + sum) / beta;
    #pragma HLS LOOP_TRIPCOUNT min=1 max=k-1
    #pragma HLS UNROLL
    for (i = 0; i < k; i++) {
      z[i] = y[i] + alpha * y[k - i - 1];
    }
    #pragma HLS LOOP_TRIPCOUNT min=1 max=k
    #pragma HLS UNROLL
    for (i = 0; i < k; i++) {
      y[i] = z[i];
    }
    y[k] = alpha;
  }
}
```

In this code, I've added the following HLS pragmas:

1. `#pragma HLS INTERFACE` directives to specify the interfaces for the function.
2. `#pragma HLS DATAFLOW` to specify that the function is a dataflow program.
3. `#pragma HLS pipeline` to specify the pipeline depth.
4. `#pragma HLS LOOP_TRIPCOUNT` directives to specify the loop trip count.
5. `#pragma HLS UNROLL` directives to specify the loop unrolling factor.

The HLS pragmas are used to optimize the code for performance and resource usage. The `#pragma HLS INTERFACE` directives specify the interfaces for the function, which allows the compiler to generate optimized code for the specific interfaces. The `#pragma HLS DATAFLOW` directive specifies that the function is a dataflow program, which allows the compiler to generate optimized code for dataflow programs.

The `#pragma HLS pipeline` directive specifies the pipeline depth, which allows the compiler to generate optimized code for pipelined programs. The `#pragma HLS LOOP_TRIPCOUNT` directives specify the loop trip count, which allows the compiler to generate optimized code for loops with known trip counts. The `#pragma HLS UNROLL` directives specify the loop unrolling factor, which allows the compiler to generate optimized code for loops with known trip counts.

By using these HLS pragmas, the compiler can generate optimized code that is more efficient and uses fewer resources than the original code.