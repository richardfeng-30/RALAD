=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
for (i = N − 1; i > 0; i−−) {
shift reg[i] = shift reg[i − 1];
}
shift reg[0] = x;
acc = 0;
MAC:

Example 2: 
void matrixmul(int A[N][M], int B[M][P], int AB[N][P]) {
#pragma HLS ARRAY RESHAPE variable=A complete dim=2
#pragma HLS ARRAY RESHAPE variable=B complete dim=1
/∗ for each row and column of AB ∗/
row: for(int i = 0; i < N; ++i) {
col: for(int j = 0; j < P; ++j) {
#pragma HLS PIPELINE II=1
/∗ compute (AB)i,j ∗/

Example 3: 
int ABij = 0;
product: for(int k = 0; k < M; ++k) {
ABij += A[i][k] ∗ B[k][j];
}
AB[i][j] = ABij;
}
}
}
Figure 7.1: A common three for loop structure for matrix multiplication. The outer for loops,
labeled rows and cols, iterate across the rows and columns of the output matrix AB. The innermost
loop, labeled product multiplies the appropriate elements of one row of A and one column of B and
accumulates them until it has the result for the element in AB .
Matrix multiplication is a fundamental operation in numerical algorithms. Computing the
product between large matrices can take a significant amount of time. Therefore, it is critically
important part of many of problems in numerical computing. Fundamentally, matrices represent linear transforms between vector spaces; matrix multiplication provides way to compose the
linear transforms. Applications include linearly changing coordinates (e.g., translation, rotation

Optimize the following code by inserting pragma HLS lines. Before responding with any code, think step by step about the HLS optimizations that will improve performance and explain your reasoning. Finally, generate the C code with pragma HLS.
void kernel_ludcmp(int n,float A[120][120],float b[120],float x[120],float y[120])
{
  int i;
  int j;
  int k;
  float w;
{
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < i; j++) {
        w = A[i][j];
        for (k = 0; k < j; k++) {
          w -= A[i][k] * A[k][j];
        }
        A[i][j] = w / A[j][j];
      }
      
      for (j = i; j < 120; j++) {
        w = A[i][j];
        for (k = 0; k < i; k++) {
          w -= A[i][k] * A[k][j];
        }
        A[i][j] = w;
      }
    }
    
    
    
    for (i = 0; i < 120; i++) {
      w = b[i];
      for (j = 0; j < i; j++) {
        w -= A[i][j] * y[j];
      }
      y[i] = w;
    }
    
    
    
    for (i = 0; i <= 119; i++) {
      int _in_i = 119 + -1 * i;
      w = y[_in_i];
      for (j = _in_i + 1; j < 120; j++) {
        w -= A[_in_i][j] * x[j];
      }
      x[_in_i] = w / A[_in_i][_in_i];
    }
    i = 0 + -1;
  }
}


=== LLAMA RESPONSE ===
Here is the optimized C code with HLS pragmas:

```c
void kernel_ludcmp(int n, float A[120][120], float b[120], float x[120], float y[120]) {
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=b offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=x offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=y offset=slave bundle=gmem

  int i;
  int j;
  int k;
  float w;

  // Partial Pivoting
  #pragma HLS DATAFLOW

  // Gaussian Elimination
  for (i = 0; i < 120; i++) {
    #pragma HLS LOOP_TRIPCOUNT min=1 max=120
    #pragma HLS PIPELINE II=1

    for (j = 0; j < i; j++) {
      w = A[i][j];
      #pragma HLS UNROLL
      for (k = 0; k < j; k++) {
        w -= A[i][k] * A[k][j];
      }
      A[i][j] = w / A[j][j];
    }

    for (j = i; j < 120; j++) {
      w = A[i][j];
      #pragma HLS UNROLL
      for (k = 0; k < i; k++) {
        w -= A[i][k] * A[k][j];
      }
      A[i][j] = w;
    }
  }

  // Forward Substitution
  for (i = 0; i < 120; i++) {
    #pragma HLS LOOP_TRIPCOUNT min=1 max=120
    #pragma HLS PIPELINE II=1

    w = b[i];
    #pragma HLS UNROLL
    for (j = 0; j < i; j++) {
      w -= A[i][j] * y[j];
    }
    y[i] = w;
  }

  // Back Substitution
  for (i = 119; i >= 0; i--) {
    #pragma HLS LOOP_TRIPCOUNT min=1 max=120
    #pragma HLS PIPELINE II=1

    w = y[i];
    #pragma HLS UNROLL
    for (j = i + 1; j < 120; j++) {
      w -= A[i][j] * x[j];
    }
    x[i] = w / A[i][i];
  }
}
```

In this code, I have added the following HLS pragmas:

1.  `#pragma HLS INTERFACE m_axi` pragmas to specify the memory interfaces for the arrays A, b, x, and y.
2.  `#pragma HLS DATAFLOW` to indicate that the code is a dataflow program.
3.  `#pragma HLS LOOP_TRIPCOUNT` pragmas to specify the minimum and maximum number of iterations for each loop.
4.  `#pragma HLS PIPELINE II=1` pragmas to specify a pipeline with a latency of 1 clock cycle for each loop.
5.  `#pragma HLS UNROLL` pragmas to unroll the inner loops to improve performance.

These pragmas can help improve the performance of the code by reducing the number of memory accesses, increasing the parallelism, and improving the pipelining.