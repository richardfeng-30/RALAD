=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
for (j = 0; j < SIZE; j++) {
sum += V In[j] ∗ M[i][j];
}
V Out[i] = sum;
}
}
Figure 4.11: Matrix-vector multiplication with a particular choice of array partitioning and pipelining.

i
Function Interval = 13

V In[0]

Loop Interval = 1

V In[1]

M[][0]

V In[2]

M[][1]

V In[3]

M[][2]

V In[4]

M[][3]

V In[5]

M[][4]

V In[6]

M[][5]

V In[7]

M[][6]

Loop Latency = 6

M[][7]

Function Latency = 13

V in[]

V Out[]

V out[i]

Figure 4.12: Matrix-vector multiplication architecture with a particular choice of array partitioning
and pipelining. The pipelining registers have been elided and the behavior is shown at right.

89

DISCRETE FOURIER TRANSFORM

V In[2]

M[][1]

V In[3]

M[][2]

V In[4]

M[][3]

V In[5]

M[][4]

V In[6]

M[][5]

V In[7]

M[][6]
M[][7]

j%3

i,j%3
V In[0-2]
V In[3-5]
V In[6-7]

M[][0-2]
M[][3-5]

To Adders

M[][0]

To Adders

V In[1]

To Adders

V In[0]

To Adders

i

M[][6-7]

Example 2: 
for (i = N − 1; i > 0; i−−) {
shift reg[i] = shift reg[i − 1];
}
shift reg[0] = x;
acc = 0;
MAC:

Example 3: 
for (j = 0; j < SIZE; j++) {
sum += V In[j] ∗ M[i][j];
}
V Out[i] = sum;
}
}
Figure 4.4: Simple code implementing a matrix-vector multiplication.

Optimize the following code by inserting pragma HLS lines. Before responding with any code, think step by step about the HLS optimizations that will improve performance and explain your reasoning. Finally, generate the C code with pragma HLS.
void kernel_mvt(int n,float x1[120],float x2[120],float y_1[120],float y_2[120],float A[120][120])
{
  int i;
  int j;
{
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < 120; j++) {
        x1[i] = x1[i] + A[i][j] * y_1[j];
      }
    }
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < 120; j++) {
        x2[i] = x2[i] + A[j][i] * y_2[j];
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here's the optimized C code with HLS pragmas:

```c
void kernel_mvt(int n, float x1[120], float x2[120], float y_1[120], float y_2[120], float A[120][120])
{
  #pragma HLS interface m_axi port=x1[0] bundle=gmem
  #pragma HLS interface m_axi port=x2[0] bundle=gmem
  #pragma HLS interface m_axi port=y_1[0] bundle=gmem
  #pragma HLS interface m_axi port=y_2[0] bundle=gmem
  #pragma HLS interface m_axi port=A[0] bundle=gmem
  
  #pragma HLS dataflow
  
  #pragma HLS pipeline II=1
  #pragma HLS pipeline enable_reset
  
  int i;
  int j;
  
  #pragma HLS loop_tripcount min=120 max=120
  #pragma HLS loop_bounds c=0 e=119
  
  for (i = 0; i < 120; i++) {
    #pragma HLS loop_tripcount min=120 max=120
    #pragma HLS loop_bounds c=0 e=119
    
    float sum = 0.0;
    
    #pragma HLS loop_pipelineable
    for (j = 0; j < 120; j++) {
      sum += A[i][j] * y_1[j];
    }
    
    x1[i] = sum;
  }
  
  #pragma HLS loop_tripcount min=120 max=120
  #pragma HLS loop_bounds c=0 e=119
  
  for (i = 0; i < 120; i++) {
    #pragma HLS loop_tripcount min=120 max=120
    #pragma HLS loop_bounds c=0 e=119
    
    float sum = 0.0;
    
    #pragma HLS loop_pipelineable
    for (j = 0; j < 120; j++) {
      sum += A[j][i] * y_2[j];
    }
    
    x2[i] = sum;
  }
}
```

Here's the reasoning behind the HLS pragmas:

1.  We use `#pragma HLS interface` to specify the memory interface for each array. This allows the compiler to optimize the memory access and reduce the memory bandwidth.
2.  We use `#pragma HLS dataflow` to specify that the function is a dataflow program. This allows the compiler to optimize the dataflow and reduce the number of memory accesses.
3.  We use `#pragma HLS pipeline` to specify that the loops are pipelined. This allows the compiler to optimize the pipeline and reduce the latency.
4.  We use `#pragma HLS loop_tripcount` and `#pragma HLS loop_bounds` to specify the trip count and bounds for each loop. This allows the compiler to optimize the loop and reduce the number of iterations.
5.  We use `#pragma HLS loop_pipelineable` to specify that the inner loop is pipelineable. This allows the compiler to optimize the pipeline and reduce the latency.

By using these HLS pragmas, we can optimize the code for performance and reduce the memory bandwidth.