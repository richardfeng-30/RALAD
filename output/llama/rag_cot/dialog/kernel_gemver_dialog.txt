=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
for (i = N − 1; i > 0; i−−) {
shift reg[i] = shift reg[i − 1];
}
shift reg[0] = x;
acc = 0;
MAC:

Example 2: 
void matrix vector(BaseType M[SIZE][SIZE], BaseType V In[SIZE], BaseType V Out[SIZE]) {
BaseType i, j;
data loop:
for (i = 0; i < SIZE; i++) {
BaseType sum = 0;
dot product loop:

Example 3: 
void matrix vector(BaseType M[SIZE][SIZE], BaseType V In[SIZE], BaseType V Out[SIZE]) {
BaseType i, j;
data loop:

Optimize the following code by inserting pragma HLS lines. Before responding with any code, think step by step about the HLS optimizations that will improve performance and explain your reasoning. Finally, generate the C code with pragma HLS.

void kernel_gemver(int n,float alpha,float beta,float A[120][120],float u1[120],float v1[120],float u2[120],float v2[120],float w[120],float x[120],float y[120],float z[120])
{
  int i;
  int j;
{
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < 120; j++) {
        A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];
      }
    }
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < 120; j++) {
        x[i] = x[i] + beta * A[j][i] * y[j];
      }
    }
    
    for (i = 0; i < 120; i++) {
      x[i] = x[i] + z[i];
    }
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < 120; j++) {
        w[i] = w[i] + alpha * A[i][j] * x[j];
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here's the optimized code with HLS pragmas:

```c
void kernel_gemver(int n, float alpha, float beta, float A[120][120], float u1[120], float v1[120], float u2[120], float v2[120], float w[120], float x[120], float y[120], float z[120]) {
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=u1 offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=v1 offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=u2 offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=v2 offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=w offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=x offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=y offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=z offset=slave bundle=gmem
  #pragma HLS INTERFACE s_axli port=n
  #pragma HLS INTERFACE s_axli port=alpha
  #pragma HLS INTERFACE s_axli port=beta
  #pragma HLS INTERFACE s_axli port=x
  #pragma HLS INTERFACE s_axli port=y
  #pragma HLS INTERFACE s_axli port=z
  #pragma HLS INTERFACE s_axli port=w

  int i;
  int j;

  #pragma HLS DATAFLOW

  // Matrix-vector multiplication
  #pragma HLS LOOP_TRIPCOUNT min=1 max=120
  for (i = 0; i < 120; i++) {
    for (j = 0; j < 120; j++) {
      A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];
    }
  }

  // Matrix-vector multiplication
  #pragma HLS LOOP_TRIPCOUNT min=1 max=120
  for (i = 0; i < 120; i++) {
    for (j = 0; j < 120; j++) {
      x[i] = x[i] + beta * A[j][i] * y[j];
    }
  }

  // Vector addition
  #pragma HLS LOOP_TRIPCOUNT min=1 max=120
  for (i = 0; i < 120; i++) {
    x[i] = x[i] + z[i];
  }

  // Matrix-vector multiplication
  #pragma HLS LOOP_TRIPCOUNT min=1 max=120
  for (i = 0; i < 120; i++) {
    for (j = 0; j < 120; j++) {
      w[i] = w[i] + alpha * A[i][j] * x[j];
    }
  }
}
```

Here's my reasoning for the HLS optimizations:

1.  I added HLS pragmas for the interfaces to specify the memory interface and the number of elements.
2.  I added HLS pragmas for the loops to specify the trip count, which is the number of iterations for each loop. This helps the HLS compiler optimize the code for the specific number of iterations.
3.  I added HLS pragmas for the data flow to specify that the code is a data flow program, which means that the code is composed of a series of data flow operations.
4.  I added HLS pragmas for the loop trip count to specify the minimum and maximum number of iterations for each loop. This helps the HLS compiler optimize the code for the specific number of iterations.

These optimizations should help the HLS compiler generate more efficient code for the kernel_gemver function.