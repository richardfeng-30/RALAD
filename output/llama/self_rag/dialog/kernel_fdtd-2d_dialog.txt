=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
Discrete Fourier Transform
The Discrete Fourier Transform (DFT) plays a fundamental role in digital signal processing systems.
It is a method to change a discrete signal in the time domain to the same signal in the frequency
domain. By describing the signal as the sum of sinusoids, we can more easily compute some
functions on the signal, e.g., filtering and other linear time invariant functions. Therefore, it plays
an important role in many wireless communications, image processing, and other digital signal
processing applications.
This chapter provides an introduction to the DFT with a focus on its optimization for an FPGA
implementation. At its core, the DFT performs a matrix-vector multiplication where the matrix is
a fixed set of coefficients. The initial optimizations in Chapter 4.6 treat the DFT operation as a
simplified matrix-vector multiplication. Then, Chapter 4.6 introduces a complete implementation

Optimize the following code by inserting pragma HLS lines.
//2-D Finite Different Time Domain Kernel


void kernel_fdtd_2d(int tmax,int nx,int ny,float ex[60][80],float ey[60][80],float hz[60][80],float _fict_[40])
{
  int t;
  int i;
  int j;
{
    
    
    
    for (t = 0; t < 40; t++) {
      
      for (j = 0; j < 80; j++) {
        ey[0][j] = _fict_[t];
      }
      
      
      
      for (i = 1; i < 60; i++) {
        
        for (j = 0; j < 80; j++) {
          ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);
        }
      }
      
      
      
      for (i = 0; i < 60; i++) {
        
        for (j = 1; j < 80; j++) {
          ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);
        }
      }
      
      
      
      for (i = 0; i < 60 - 1; i++) {
        
        for (j = 0; j < 80 - 1; j++) {
          hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);
        }
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:
```c
void kernel_fdtd_2d(int tmax, int nx, int ny, float ex[60][80], float ey[60][80], float hz[60][80], float _fict_[40]) {
  #pragma HLS INTERFACE m_axi port=ex offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=ey offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=hz offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=_fict_ offset=slave bundle=gmem

  int t;
  int i;
  int j;

  #pragma HLS DATAFLOW

  // Loop unrolling for better pipeline efficiency
  #pragma HLS LOOP_TRIPCOUNT min=40 max=40
  #pragma HLS PIPELINE II=1
  for (t = 0; t < 40; t++) {
    #pragma HLS LOOP_TRIPCOUNT min=80 max=80
    for (j = 0; j < 80; j++) {
      ey[0][j] = _fict_[t];
    }

    #pragma HLS LOOP_TRIPCOUNT min=59 max=59
    for (i = 1; i < 60; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=79 max=79
      for (j = 0; j < 80; j++) {
        ey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);
      }
    }

    #pragma HLS LOOP_TRIPCOUNT min=59 max=59
    for (i = 0; i < 60; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=79 max=79
      for (j = 1; j < 80; j++) {
        ex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);
      }
    }

    #pragma HLS LOOP_TRIPCOUNT min=59 max=59
    for (i = 0; i < 59; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=79 max=79
      for (j = 0; j < 79; j++) {
        hz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);
      }
    }
  }
}
```
The pragmas used are:

* `#pragma HLS INTERFACE m_axi`: specifies the memory interface for the arrays.
* `#pragma HLS DATAFLOW`: specifies that the function is a dataflow-oriented function.
* `#pragma HLS LOOP_TRIPCOUNT`: specifies the minimum and maximum number of iterations for each loop.
* `#pragma HLS PIPELINE II=1`: specifies the pipeline depth and the number of iterations per pipeline stage.

These pragmas can help the HLS compiler optimize the code for better performance, resource utilization, and pipelining.