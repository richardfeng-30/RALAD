=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
// a can be -0.5,

ap_ufixed<1, 0> x = 0.5;
// 1-bit representation. x can be 0 or 0.5
ap_ufixed<1, -1> y = 0.25; // 1-bit representation. y can be 0 or 0.25
const ap_fixed<1, -7> z = 1.0/256; // 1-bit representation for z = 2^-8
Q

O

N

Quantization mode: This dictates the behavior when greater precision is generated than can be defined
by smallest fractional bit in the variable used to store the result.
ap_fixed Types

Description

AP_RND

Round to plus infinity

AP_RND_ZERO

Round to zero

AP_RND_MIN_INF

Round to minus infinity

AP_RND_INF

Round to infinity

AP_RND_CONV

Convergent rounding

AP_TRN

Truncation to minus infinity (default)

AP_TRN_ZERO

Truncation to zero

Overflow mode: This dictates the behavior when the result of an operation exceeds the maximum (or
minimum in the case of negative numbers) possible value that can be stored in the variable used to
store the result.
ap_fixed Types

Description

AP_SAT1

Saturation

AP_SAT_ZERO1

Saturation to zero

AP_SAT_SYM1

Example 2: 
// Calculate matrix multiplication using local data buffer based on input size,
// and write results into local buffer for out
loop_count:
    for (int i = 0; i < rep_count; i++) {
    arraypart1:
        for (int row = 0; row < size; row++) {
#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim
        arraypart2:
            for (int col = 0; col < size; col++) {
#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim
            arraypart3:
                for (int j = 0; j < MAX_SIZE; j++) {
#pragma HLS LOOP_TRIPCOUNT min = c_dim max = c_dim
                    int result = (col == 0) ? 0 : temp_sum[j];
                    result += A[row][col] * B[col][j];
                    temp_sum[j] = result;
                    if (col == size - 1) C[row][j] = result;
                }
            }
        }
    }

Optimize the following code by inserting pragma HLS lines.
//2D Seidel Computation

void kernel_seidel_2d(int tsteps,int n,float A[120][120])
{
  int t;
  int i;
  int j;
{
    
    
    
    for (t = 0; t <= 40 - 1; t++) {
      
      
      
      for (i = 1; i <= 120 - 2; i++) {
        
        for (j = 1; j <= 120 - 2; j++) {
          A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;
        }
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:

```c
void kernel_seidel_2d(int tsteps, int n, float A[120][120]) {
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE s_axli port=n offset=slave
  #pragma HLS INTERFACE s_axli port=tsteps offset=slave
  #pragma HLS INTERFACE s_axli port=return offset=slave

  int t;
  int i;
  int j;

  #pragma HLS DATAFLOW
  #pragma HLS LOOP_TRIPCOUNT min=41 max=41
  for (t = 0; t <= 40 - 1; t++) {
    #pragma HLS LOOP_TRIPCOUNT min=119 max=119
    for (i = 1; i <= 120 - 2; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=119 max=119
      for (j = 1; j <= 120 - 2; j++) {
        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;
      }
    }
  }
}
```

Note: I've added HLS pragmas for interfaces, loops, and dataflow. The `LOOP_TRIPCOUNT` pragmas are used to specify the minimum and maximum number of iterations for each loop. The `DATAFLOW` pragma is used to specify that the code is a dataflow program, which allows the HLS compiler to optimize the code for parallelism.