=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
void dut(int in[N], int out[N], int n) {
#pragma HLS dataflow
hls::split::round_robin<int, NP> split1;
hls::merge::round_robin<int, NP> merge1;
read_in(in, n, split1.in);
// Task-Channels
hls_thread_local hls::task t[NP];

Example 2: 
void dut(const double* in, // Read-Only Vector 1
         double* out,      // Output Result
         int size          // Size in integer
) {

#pragma HLS INTERFACE mode = m_axi bundle = aximm2 depth =                     \
    1025 max_read_burst_length = 128 num_read_outstanding = 256 port = in
#pragma HLS INTERFACE m_axi port = out bundle = aximm depth = 1024

#pragma HLS cache port = in lines = 1 depth = 128

    for (int i = 0; i < size; i++) {
        out[i] = in[i] + in[i + 1];
    }
}
}

Optimize the following code by inserting pragma HLS lines.

void kernel_durbin(int n,float r[120],float y[120])
{
  float z[120];
  float alpha;
  float beta;
  float sum;
  int i;
  int k;
{
    y[0] = -r[0];
    beta = 1.0;
    alpha = -r[0];
    
    
    
    for (k = 1; k < 120; k++) {
      beta = (((float )1) - alpha * alpha) * beta;
      sum = 0.0;
      for (i = 0; i < k; i++) {
        sum += r[k - i - 1] * y[i];
      }
      alpha = -(r[k] + sum) / beta;
      for (i = 0; i < k; i++) {
        z[i] = y[i] + alpha * y[k - i - 1];
      }
      for (i = 0; i < k; i++) {
        y[i] = z[i];
      }
      y[k] = alpha;
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:

```c
void kernel_durbin(int n, float r[120], float y[120]) {
#pragma HLS INTERFACE m_axi port = r bundle = aximm depth = 120
#pragma HLS INTERFACE m_axi port = y bundle = aximm depth = 120

#pragma HLS cache port = r lines = 1 depth = 128
#pragma HLS cache port = y lines = 1 depth = 128

  float z[120];
  float alpha;
  float beta;
  float sum;
  int i;
  int k;

  y[0] = -r[0];
  beta = 1.0;
  alpha = -r[0];

  #pragma HLS loop_tripcount min = 1 max = 119
  for (k = 1; k < 120; k++) {
    beta = (((float )1) - alpha * alpha) * beta;
    #pragma HLS loop_tripcount min = 1 max = k
    sum = 0.0;
    for (i = 0; i < k; i++) {
      sum += r[k - i - 1] * y[i];
    }
    alpha = -(r[k] + sum) / beta;
    #pragma HLS loop_tripcount min = 1 max = k
    for (i = 0; i < k; i++) {
      z[i] = y[i] + alpha * y[k - i - 1];
    }
    #pragma HLS loop_tripcount min = 1 max = k
    for (i = 0; i < k; i++) {
      y[i] = z[i];
    }
    y[k] = alpha;
  }
}
```

I added the following HLS pragmas:

* `#pragma HLS INTERFACE m_axi` to specify the interface for the input and output arrays.
* `#pragma HLS cache` to specify the cache settings for the input and output arrays.
* `#pragma HLS loop_tripcount` to specify the trip count for the loops. This can help the HLS compiler optimize the loop iterations.

Note that you may need to adjust the trip counts and cache settings based on the specific requirements of your design.