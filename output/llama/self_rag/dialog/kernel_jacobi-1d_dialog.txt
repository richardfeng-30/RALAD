=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
// Write out resulting row of C
    for (int m = 0; m < M; ++m) {
      #pragma HLS PIPELINE II=1
      C[n * M + m] = acc[m];
    }
  }
}



Example 6
This example plays with scaling up parallelism in a matrix multiplication example. We add two degrees of parallelism: horizontal vector parallelism, which consumes bandwidth, and pipeline parallelism, which consumes buffer space. In xilinx/Example6.cpp, rather than loading a single value of a before the inner M-loop, we load a higher (parametric) number of elements, allowing us to apply each of them to every value of B loaded. In xilinx/Example6_Vectorized.cpp, we additionally add vectorization, by replacing the primitive data types with vector types, and adjusting the loop bounds accordingly. The two files can be synthesized with make synthesize_example6 and make synthesize_example6_vectorized, respectively.

Optimize the following code by inserting pragma HLS lines.
//1-D Jacobi Stencil Computation

void kernel_jacobi_1d(int tsteps,int n,float A[120],float B[120])
{
  int t;
  int i;
{
    
    
    
    for (t = 0; t < 40; t++) {
      
      for (i = 1; i < 120 - 1; i++) {
        B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);
      }
      
      for (i = 1; i < 120 - 1; i++) {
        A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:

```c
void kernel_jacobi_1d(int tsteps, int n, float A[120], float B[120]) {
  int t;
  int i;
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem

  for (t = 0; t < 40; t++) {
    #pragma HLS PIPELINE II=1
    for (i = 1; i < 120 - 1; i++) {
      #pragma HLS UNROLL factor=4
      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);
    }
    
    for (i = 1; i < 120 - 1; i++) {
      #pragma HLS UNROLL factor=4
      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);
    }
  }
}
```

In this code, I added the following HLS pragmas:

1. `#pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem` and `#pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem`: These pragmas specify the interfaces for the `A` and `B` arrays, which are accessed as AXI masters.

2. `#pragma HLS PIPELINE II=1`: This pragma enables pipelining for the outer loop, which runs for `tsteps` iterations. The `II=1` option specifies that the pipeline stage should be executed in one clock cycle.

3. `#pragma HLS UNROLL factor=4`: This pragma unrolls the inner loops by a factor of 4, which can improve performance by reducing the number of loop iterations.