=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
Optimize the following code by inserting pragma HLS lines. Before responding with any code, think step by step about the HLS optimizations that will improve performance and explain your reasoning. Finally, generate the C code with pragma HLS.


void kernel_durbin(int n,float r[120],float y[120])
{
  float z[120];
  float alpha;
  float beta;
  float sum;
  int i;
  int k;
{
    y[0] = -r[0];
    beta = 1.0;
    alpha = -r[0];
    
    
    
    for (k = 1; k < 120; k++) {
      beta = (((float )1) - alpha * alpha) * beta;
      sum = 0.0;
      for (i = 0; i < k; i++) {
        sum += r[k - i - 1] * y[i];
      }
      alpha = -(r[k] + sum) / beta;
      for (i = 0; i < k; i++) {
        z[i] = y[i] + alpha * y[k - i - 1];
      }
      for (i = 0; i < k; i++) {
        y[i] = z[i];
      }
      y[k] = alpha;
    }
  }
}


=== LLAMA RESPONSE ===
Before inserting the HLS pragmas, let's analyze the code and identify potential optimization opportunities:

1. The code has three nested loops, which can be a performance bottleneck. We can use HLS pragmas to pipeline and unroll these loops to improve parallelism and reduce memory access.
2. The code has many floating-point operations, which can be optimized using HLS pragmas for vectorization and parallelization.
3. The code has a lot of memory accesses, which can be optimized using HLS pragmas for cache-friendly memory access and memory allocation.

Here's the optimized C code with HLS pragmas:
```c
void kernel_durbin(int n, float r[120], float y[120])
{
  #pragma HLS INTERFACE m_axi port=r[0] depth=120
  #pragma HLS INTERFACE m_axi port=y[0] depth=120
  #pragma HLS INTERFACE m_axi port=z[0] depth=120

  float z[120];
  float alpha;
  float beta;
  float sum;
  int i;
  int k;

  #pragma HLS DATAFLOW

  // Initialize y[0] and beta
  y[0] = -r[0];
  beta = 1.0;
  alpha = -r[0];

  #pragma HLS LOOP_PIPELINE II=120

  for (k = 1; k < 120; k++) {
    #pragma HLS UNROLL factor=4

    beta = (((float )1) - alpha * alpha) * beta;
    sum = 0.0;
    #pragma HLS LOOP_PIVOT

    for (i = 0; i < k; i++) {
      sum += r[k - i - 1] * y[i];
    }

    alpha = -(r[k] + sum) / beta;
    #pragma HLS LOOP_PIVOT

    for (i = 0; i < k; i++) {
      z[i] = y[i] + alpha * y[k - i - 1];
    }

    #pragma HLS LOOP_PIVOT

    for (i = 0; i < k; i++) {
      y[i] = z[i];
    }

    y[k] = alpha;
  }
}
```
Here's a brief explanation of the HLS pragmas used:

* `#pragma HLS INTERFACE m_axi`: This pragma specifies the memory interface for the input arrays `r`, `y`, and `z`.
* `#pragma HLS DATAFLOW`: This pragma enables dataflow scheduling for the entire kernel, which allows the compiler to optimize the code for parallel execution.
* `#pragma HLS LOOP_PIPELINE II=120`: This pragma pipelines the outer loop with a pipeline depth of 120, which allows the compiler to schedule the loop iterations in parallel.
* `#pragma HLS UNROLL factor=4`: This pragma unrolls the inner loop with a factor of 4, which allows the compiler to schedule the loop iterations in parallel.
* `#pragma HLS LOOP_PIVOT`: This pragma enables loop pivoting for the inner loops, which allows the compiler to optimize the loop iterations for better cache locality and parallelism.

These HLS pragmas should improve the performance of the kernel by reducing memory access, increasing parallelism, and optimizing loop execution.