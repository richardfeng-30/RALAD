=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
Optimize the following code by inserting pragma HLS lines. Before responding with any code, think step by step about the HLS optimizations that will improve performance and explain your reasoning. Finally, generate the C code with pragma HLS.


void kernel_atax(int m,int n,float A[116][124],float x[124],float y[124],float tmp[116])
{
  int i;
  int j;
{
    
    for (i = 0; i < 124; i++) {
      y[i] = ((float )0);
    }
    
    
    
    for (i = 0; i < 116; i++) {
      tmp[i] = 0.0;
      
      for (j = 0; j < 124; j++) {
        tmp[i] = tmp[i] + A[i][j] * x[j];
      }
      
      for (j = 0; j < 124; j++) {
        y[j] = y[j] + A[i][j] * tmp[i];
      }
    }
  }
}


=== LLAMA RESPONSE ===
The provided C code is a kernel function that performs a matrix-vector multiplication followed by a matrix-matrix multiplication. The HLS (High-Level Synthesis) optimization can be applied to this code to improve its performance and resource utilization.

Here's a step-by-step approach to optimize the code:

1.  **Pragma HLS Interface**: The input and output arrays `A`, `x`, `y`, and `tmp` are accessed frequently in the code. To optimize the memory access, we can use the `pragma HLS interface` directive to specify the memory interfaces.

2.  **Pragma HLS Loop Pipelining**: The innermost loop in the code is a simple addition operation. This loop can be pipelined to improve the throughput. The `pragma HLS loop_pipelining` directive can be used to pipeline the loop.

3.  **Pragma HLS Loop Unrolling**: The middle loop in the code is a dot product calculation. This loop can be unrolled to reduce the number of iterations and improve the performance. The `pragma HLS loop_unroll` directive can be used to unroll the loop.

4.  **Pragma HLS Storage**: The temporary array `tmp` is used to store the intermediate results. To reduce the memory usage, we can use the `pragma HLS storage` directive to allocate the array in the on-chip memory.

Here's the optimized C code with the `pragma HLS` directives:

```c
void kernel_atax(int m, int n, float A[116][124], float x[124], float y[124], float tmp[116])
{
    #pragma HLS INTERFACE m_axi port=A offset=slave
    #pragma HLS INTERFACE m_axi port=x offset=slave
    #pragma HLS INTERFACE m_axi port=y offset=slave
    #pragma HLS INTERFACE m_axi port=tmp offset=slave
    #pragma HLS INTERFACE s_axilite port=m
    #pragma HLS INTERFACE s_axilite port=n
    #pragma HLS INTERFACE s_axilite port=A
    #pragma HLS INTERFACE s_axilite port=x
    #pragma HLS INTERFACE s_axilite port=y
    #pragma HLS INTERFACE s_axilite port=tmp
    #pragma HLS INTERFACE s_axilite port=return

    int i;
    int j;

    #pragma HLS dataflow

    // Initialize y array
    #pragma HLS loop_pipelining
    for (i = 0; i < 124; i++) {
        y[i] = 0.0;
    }

    // Calculate dot product
    #pragma HLS loop_unroll
    for (i = 0; i < 116; i++) {
        tmp[i] = 0.0;
        #pragma HLS loop_pipelining
        for (j = 0; j < 124; j++) {
            tmp[i] = tmp[i] + A[i][j] * x[j];
        }
        #pragma HLS loop_pipelining
        for (j = 0; j < 124; j++) {
            y[j] = y[j] + A[i][j] * tmp[i];
        }
    }
}
```

In this optimized code, the `pragma HLS interface` directives specify the memory interfaces for the input and output arrays. The `pragma HLS loop_pipelining` directive is used to pipeline the innermost loop, and the `pragma HLS loop_unroll` directive is used to unroll the middle loop. The `pragma HLS storage` directive is not used in this code because the temporary array `tmp` is already allocated in the on-chip memory.