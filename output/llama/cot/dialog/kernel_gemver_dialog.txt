=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
Optimize the following code by inserting pragma HLS lines. Before responding with any code, think step by step about the HLS optimizations that will improve performance and explain your reasoning. Finally, generate the C code with pragma HLS.


void kernel_gemver(int n,float alpha,float beta,float A[120][120],float u1[120],float v1[120],float u2[120],float v2[120],float w[120],float x[120],float y[120],float z[120])
{
  int i;
  int j;
{
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < 120; j++) {
        A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];
      }
    }
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < 120; j++) {
        x[i] = x[i] + beta * A[j][i] * y[j];
      }
    }
    
    for (i = 0; i < 120; i++) {
      x[i] = x[i] + z[i];
    }
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < 120; j++) {
        w[i] = w[i] + alpha * A[i][j] * x[j];
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here's a step-by-step explanation of the HLS optimizations:

1. The innermost loops are the ones that can be parallelized. These are the loops that access the 2D array A. We can use the #pragma HLS loop_unroll directive to unroll these loops, which can improve performance by reducing the overhead of the loop control statements.

2. The next step is to optimize the memory access patterns. In this code, the memory accesses are sequential, which can be optimized using the #pragma HLS cache directive.

3. The last step is to optimize the data dependencies. In this code, there are no data dependencies between the loops, so we don't need to use any data dependency optimization directives.

Here's the optimized C code with #pragma HLS directives:

```c
void kernel_gemver(int n,float alpha,float beta,float A[120][120],float u1[120],float v1[120],float u2[120],float v2[120],float w[120],float x[120],float y[120],float z[120])
{
  #pragma HLS interface m_axi port=A[0] bundle=gmem
  #pragma HLS interface m_axi port=u1[0] bundle=gmem
  #pragma HLS interface m_axi port=v1[0] bundle=gmem
  #pragma HLS interface m_axi port=u2[0] bundle=gmem
  #pragma HLS interface m_axi port=v2[0] bundle=gmem
  #pragma HLS interface m_axi port=w[0] bundle=gmem
  #pragma HLS interface m_axi port=x[0] bundle=gmem
  #pragma HLS interface m_axi port=y[0] bundle=gmem
  #pragma HLS interface m_axi port=z[0] bundle=gmem

  int i;
  int j;
  {
    #pragma HLS loop_unroll factor=4
    for (i = 0; i < 120; i++) {
      for (j = 0; j < 120; j++) {
        A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];
      }
    }
  }
  {
    #pragma HLS loop_unroll factor=4
    for (i = 0; i < 120; i++) {
      for (j = 0; j < 120; j++) {
        x[i] = x[i] + beta * A[j][i] * y[j];
      }
    }
  }
  {
    #pragma HLS loop_unroll factor=4
    for (i = 0; i < 120; i++) {
      x[i] = x[i] + z[i];
    }
  }
  {
    #pragma HLS loop_unroll factor=4
    for (i = 0; i < 120; i++) {
      for (j = 0; j < 120; j++) {
        w[i] = w[i] + alpha * A[i][j] * x[j];
      }
    }
  }
}
```

Note that the #pragma HLS interface directives are used to specify the memory interfaces for the input and output arrays. The #pragma HLS loop_unroll directive is used to unroll the inner loops. The #pragma HLS cache directive is not needed in this case because the memory accesses are sequential.