=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
Optimize the following code by inserting pragma HLS lines. Before responding with any code, think step by step about the HLS optimizations that will improve performance and explain your reasoning. Finally, generate the C code with pragma HLS.

#include <math.h>


void kernel_deriche(int w,int h,float alpha,float imgIn[192][128],float imgOut[192][128],float y1[192][128],float y2[192][128])
{

  float xm1;
  float tm1;
  float ym1;
  float ym2;
  float xp1;
  float xp2;
  float tp1;
  float tp2;
  float yp1;
  float yp2;
  float k;
  float a1;
  float a2;
  float a3;
  float a4;
  float a5;
  float a6;
  float a7;
  float a8;
  float b1;
  float b2;
  float c1;
  float c2;
  int i;
  int j;
{
    k = (1.0f - expf(-alpha)) * (1.0f - expf(-alpha)) / (1.0f + 2.0f * alpha * expf(-alpha) - expf(2.0f * alpha));
    a1 = a5 = k;
    a2 = a6 = k * expf(-alpha) * (alpha - 1.0f);
    a3 = a7 = k * expf(-alpha) * (alpha + 1.0f);
    a4 = a8 = -k * expf(- 2.0f * alpha);
    b1 = powf(2.0f,-alpha);
    b2 = -expf(- 2.0f * alpha);
    c1 = c2 = ((float )1);
    
    
    
    for (i = 0; i < 192; i++) {
      ym1 = 0.0f;
      ym2 = 0.0f;
      xm1 = 0.0f;
      
      for (j = 0; j < 128; j++) {
        y1[i][j] = a1 * imgIn[i][j] + a2 * xm1 + b1 * ym1 + b2 * ym2;
        xm1 = imgIn[i][j];
        ym2 = ym1;
        ym1 = y1[i][j];
      }
    }
    
    
    
    for (i = 0; i < 192; i++) {
      yp1 = 0.0f;
      yp2 = 0.0f;
      xp1 = 0.0f;
      xp2 = 0.0f;
      
      for (j = 0; j <= 127; j++) {
        int _in_j = 127 + -1 * j;
        y2[i][_in_j] = a3 * xp1 + a4 * xp2 + b1 * yp1 + b2 * yp2;
        xp2 = xp1;
        xp1 = imgIn[i][_in_j];
        yp2 = yp1;
        yp1 = y2[i][_in_j];
      }
      j = 0 + -1;
    }
    
    
    
    for (i = 0; i < 192; i++) {
      
      for (j = 0; j < 128; j++) {
        imgOut[i][j] = c1 * (y1[i][j] + y2[i][j]);
      }
    }
    
    
    
    for (j = 0; j < 128; j++) {
      tm1 = 0.0f;
      ym1 = 0.0f;
      ym2 = 0.0f;
      
      for (i = 0; i < 192; i++) {
        y1[i][j] = a5 * imgOut[i][j] + a6 * tm1 + b1 * ym1 + b2 * ym2;
        tm1 = imgOut[i][j];
        ym2 = ym1;
        ym1 = y1[i][j];
      }
    }
    
    
    
    for (j = 0; j < 128; j++) {
      tp1 = 0.0f;
      tp2 = 0.0f;
      yp1 = 0.0f;
      yp2 = 0.0f;
      
      for (i = 0; i <= 191; i++) {
        int _in_i = 191 + -1 * i;
        y2[_in_i][j] = a7 * tp1 + a8 * tp2 + b1 * yp1 + b2 * yp2;
        tp2 = tp1;
        tp1 = imgOut[_in_i][j];
        yp2 = yp1;
        yp1 = y2[_in_i][j];
      }
      i = 0 + -1;
    }
    
    
    
    for (i = 0; i < 192; i++) {
      
      for (j = 0; j < 128; j++) {
        imgOut[i][j] = c2 * (y1[i][j] + y2[i][j]);
      }
    }
  }
}


=== LLAMA RESPONSE ===
To optimize the given code for HLS, I will insert the necessary #pragma HLS directives. Here's the step-by-step reasoning and the optimized code:

1.  The first loop has a dependency between iterations, which can be parallelized by using #pragma HLS pipeline II=1. This will allow the compiler to break the loop into multiple stages, processing each iteration independently.

2.  The second loop has a similar dependency, which can also be parallelized using #pragma HLS pipeline II=1.

3.  The third and fourth loops have no dependencies between iterations, so they can be parallelized using #pragma HLS pipeline II=1.

4.  The arrays imgIn, imgOut, y1, and y2 are accessed in a sequential manner, which can be optimized using #pragma HLS array_partition variable=variable block factor=8. This will allow the compiler to divide the arrays into smaller blocks and process them in parallel.

Here's the optimized code:

```c
#include <math.h>

void kernel_deriche(int w,int h,float alpha,float imgIn[192][128],float imgOut[192][128],float y1[192][128],float y2[192][128])
{
    #pragma HLS INTERFACE m_axis port=imgIn offset=slave bundle=gmem
    #pragma HLS INTERFACE m_axis port=imgOut offset=slave bundle=gmem
    #pragma HLS INTERFACE m_axis port=y1 offset=slave bundle=gmem
    #pragma HLS INTERFACE m_axis port=y2 offset=slave bundle=gmem

    float xm1;
    float tm1;
    float ym1;
    float ym2;
    float xp1;
    float xp2;
    float tp1;
    float tp2;
    float yp1;
    float yp2;
    float k;
    float a1;
    float a2;
    float a3;
    float a4;
    float a5;
    float a6;
    float a7;
    float a8;
    float b1;
    float b2;
    float c1;
    float c2;
    int i;
    int j;

    k = (1.0f - expf(-alpha)) * (1.0f - expf(-alpha)) / (1.0f + 2.0f * alpha * expf(-alpha) - expf(2.0f * alpha));
    a1 = a5 = k;
    a2 = a6 = k * expf(-alpha) * (alpha - 1.0f);
    a3 = a7 = k * expf(-alpha) * (alpha + 1.0f);
    a4 = a8 = -k * expf(- 2.0f * alpha);
    b1 = powf(2.0f,-alpha);
    b2 = -expf(- 2.0f * alpha);
    c1 = c2 = ((float )1);

    #pragma HLS pipeline II=1
    for (i = 0; i < 192; i++) {
        ym1 = 0.0f;
        ym2 = 0.0f;
        xm1 = 0.0f;

        #pragma HLS array_partition variable=imgIn block factor=8
        #pragma HLS array_partition variable=imgOut block factor=8
        #pragma HLS array_partition variable=y1 block factor=8
        #pragma HLS array_partition variable=y2 block factor=8

        for (j = 0; j < 128; j++) {
            y1[i][j] = a1 * imgIn[i][j] + a2 * xm1 + b1 * ym1 + b2 * ym2;
            xm1 = imgIn[i][j];
            ym2 = ym1;
            ym1 = y1[i][j];
        }
    }

    #pragma HLS pipeline II=1
    for (i = 0; i < 192; i++) {
        yp1 = 0.0f;
        yp2 = 0.0f;
        xp1 = 0.0f;
        xp2 = 0.0f;

        for (j = 0; j <= 127; j++) {
            int _in_j = 127 + -1 * j;
            y2[i][_in_j] = a3 * xp1 + a4 * xp2 + b1 * yp1 + b2 * yp2;
            xp2 = xp1;
            xp1 = imgIn[i][_in_j];
            yp2 = yp1;
            yp1 = y2[i][_in_j];
        }
        j = 0 + -1;
    }

    #pragma HLS pipeline II=1
    for (i = 0; i < 192; i++) {
        for (j = 0; j < 128; j++) {
            imgOut[i][j] = c1 * (y1[i][j] + y2[i][j]);
        }
    }

    #pragma HLS pipeline II=1
    for (j = 0; j < 128; j++) {
        tm1 = 0.0f;
        ym1 = 0.0f;
        ym2 = 0.0f;

        for (i = 0; i < 192; i++) {
            y1[i][j] = a5 * imgOut[i][j] + a6 * tm1 + b1 * ym1 + b2 * ym2;
            tm1 = imgOut[i][j];
            ym2 = ym1;
            ym1 = y1[i][j];
        }
    }

    #pragma HLS pipeline II=1
    for (j = 0; j < 128; j++) {
        tp1 = 0.0f;
        tp2 = 0.0f;
        yp1 = 0.0f;
        yp2 = 0.0f;

        for (i = 0; i <= 191; i++) {
            int _in_i = 191 + -1 * i;
            y2[_in_i][j] = a7 * tp1 + a8 * tp2 + b1 * yp1 + b2 * yp2;
            tp2 = tp1;
            tp1 = imgOut[_in_i][j];
            yp2 = yp1;
            yp1 = y2[_in_i][j];
        }
        i = 0 + -1;
    }

    #pragma HLS pipeline II=1
    for (i = 0; i < 192; i++) {
        for (j = 0; j < 128; j++) {
            imgOut[i][j] = c2 * (y1[i][j] + y2[i][j]);
        }
    }
}
```

Note that the #pragma HLS directives should be placed carefully to ensure that the compiler can effectively optimize the code.