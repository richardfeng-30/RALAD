=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
for (i = N − 1; i > 0; i−−) {
shift reg[i] = shift reg[i − 1];
}
shift reg[0] = x;
acc = 0;
MAC:

Example 2: 
void matrixmul(int A[N][M], int B[M][P], int AB[N][P]) {
#pragma HLS ARRAY RESHAPE variable=A complete dim=2
#pragma HLS ARRAY RESHAPE variable=B complete dim=1
/∗ for each row and column of AB ∗/
row: for(int i = 0; i < N; ++i) {
col: for(int j = 0; j < P; ++j) {
#pragma HLS PIPELINE II=1
/∗ compute (AB)i,j ∗/

Example 3: 
int ABij = 0;
product: for(int k = 0; k < M; ++k) {
ABij += A[i][k] ∗ B[k][j];
}
AB[i][j] = ABij;
}
}
}
Figure 7.1: A common three for loop structure for matrix multiplication. The outer for loops,
labeled rows and cols, iterate across the rows and columns of the output matrix AB. The innermost
loop, labeled product multiplies the appropriate elements of one row of A and one column of B and
accumulates them until it has the result for the element in AB .
Matrix multiplication is a fundamental operation in numerical algorithms. Computing the
product between large matrices can take a significant amount of time. Therefore, it is critically
important part of many of problems in numerical computing. Fundamentally, matrices represent linear transforms between vector spaces; matrix multiplication provides way to compose the
linear transforms. Applications include linearly changing coordinates (e.g., translation, rotation

Optimize the following code by inserting pragma HLS lines.
void kernel_ludcmp(int n,float A[120][120],float b[120],float x[120],float y[120])
{
  int i;
  int j;
  int k;
  float w;
{
    
    
    
    for (i = 0; i < 120; i++) {
      
      for (j = 0; j < i; j++) {
        w = A[i][j];
        for (k = 0; k < j; k++) {
          w -= A[i][k] * A[k][j];
        }
        A[i][j] = w / A[j][j];
      }
      
      for (j = i; j < 120; j++) {
        w = A[i][j];
        for (k = 0; k < i; k++) {
          w -= A[i][k] * A[k][j];
        }
        A[i][j] = w;
      }
    }
    
    
    
    for (i = 0; i < 120; i++) {
      w = b[i];
      for (j = 0; j < i; j++) {
        w -= A[i][j] * y[j];
      }
      y[i] = w;
    }
    
    
    
    for (i = 0; i <= 119; i++) {
      int _in_i = 119 + -1 * i;
      w = y[_in_i];
      for (j = _in_i + 1; j < 120; j++) {
        w -= A[_in_i][j] * x[j];
      }
      x[_in_i] = w / A[_in_i][_in_i];
    }
    i = 0 + -1;
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:

```c
void kernel_ludcmp(int n,float A[120][120],float b[120],float x[120],float y[120])
{
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=b offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=x offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=y offset=slave bundle=gmem
  #pragma HLS INTERFACE s_axli port=n
  #pragma HLS INTERFACE s_axli port=return

  int i;
  int j;
  int k;
  float w;
  #pragma HLS DATAFLOW

  // Forward Elimination
  #pragma HLS LOOP_TRIPCOUNT min=120 max=120
  for (i = 0; i < 120; i++) {
    #pragma HLS LOOP_TRIPCOUNT min=i max=i
    for (j = 0; j < i; j++) {
      w = A[i][j];
      #pragma HLS LOOP_TRIPCOUNT min=j max=j
      for (k = 0; k < j; k++) {
        w -= A[i][k] * A[k][j];
      }
      A[i][j] = w / A[j][j];
    }
    #pragma HLS LOOP_TRIPCOUNT min=i max=i
    for (j = i; j < 120; j++) {
      w = A[i][j];
      #pragma HLS LOOP_TRIPCOUNT min=i max=i
      for (k = 0; k < i; k++) {
        w -= A[i][k] * A[k][j];
      }
      A[i][j] = w;
    }
  }

  // Solve for y
  #pragma HLS LOOP_TRIPCOUNT min=120 max=120
  for (i = 0; i < 120; i++) {
    w = b[i];
    #pragma HLS LOOP_TRIPCOUNT min=i max=i
    for (j = 0; j < i; j++) {
      w -= A[i][j] * y[j];
    }
    y[i] = w;
  }

  // Back Substitution
  #pragma HLS LOOP_TRIPCOUNT min=120 max=120
  for (i = 0; i <= 119; i++) {
    int _in_i = 119 + -1 * i;
    w = y[_in_i];
    #pragma HLS LOOP_TRIPCOUNT min=_in_i max=_in_i
    for (j = _in_i + 1; j < 120; j++) {
      w -= A[_in_i][j] * x[j];
    }
    x[_in_i] = w / A[_in_i][_in_i];
  }
}
```

Note: The above code assumes that the input matrices A, b, x, y are stored in global memory and the output matrices x, y are stored in global memory. Also, the pragmas are inserted to optimize the code for a Xilinx FPGA.