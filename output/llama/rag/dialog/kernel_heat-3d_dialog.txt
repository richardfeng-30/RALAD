=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
int N2 = SIZE2; // N2=N>>1
bit reverse(X R, X I);
step = N2;
DTYPE a, e, c, s;
stage loop:
for (stage = 1; stage <= M; stage++) {
// Do M stages of butterflies
DFTpts = 1 << stage;
// DFT = 2ˆstage = points in sub DFT
numBF = DFTpts / 2;
// Butterfly WIDTHS in sub−DFT
k = 0;
e = −6.283185307178 / DFTpts;
a = 0.0;
// Perform butterflies for j−th stage
butterfly loop:
for (j = 0; j < numBF; j++) {
c = cos(a);
s = sin(a);
a = a + e;
// Compute butterflies that use same W∗∗k
dft loop:

Example 2: 
void fir(data t ∗y, data t x) {
coef t c[N] = {
53, 0, −91, 0, 313, 500, 313, 0, −91, 0, 53
};
static
data t shift reg[N];
acc t acc;

Example 3: 
later in the design optimization process. The matrix swout and matrix hwout are both initialized to
0. These are filled in later by calls to the functions matmatmul sw and blockmatmul.
The second part of the testbench is continued in Figure 7.7. This has the last portion of the
code from the main function.
The first part of this figure has a complex set of nested for loops. The overall goal of the
computation in these for loops is to set up the data from the input matrices A and B so that it
can be streamed to the blockmatmul function. Then the results of the blockmatmul function are
stored in the matrix hwout array.
The outer two for loops are used to step across the input arrays in a blocked manner. You can
see that these both iterate by a step of BLOCK SIZE. The next two for loops write rows from A
into strm matrix1 element and the columns from B into strm matrix2 element. It does this in an

Optimize the following code by inserting pragma HLS lines.

void kernel_heat_3d(int tsteps,int n,float A[20][20][20],float B[20][20][20])
{
  int t;
  int i;
  int j;
  int k;
{
    
    
    
    for (t = 1; t <= 40; t++) {
      
      
      for (i = 1; i < 20 - 1; i++) {
        
        
        for (j = 1; j < 20 - 1; j++) {
          for (k = 1; k < 20 - 1; k++) {
            B[i][j][k] = 0.125 * (A[i + 1][j][k] - 2.0 * A[i][j][k] + A[i - 1][j][k]) + 0.125 * (A[i][j + 1][k] - 2.0 * A[i][j][k] + A[i][j - 1][k]) + 0.125 * (A[i][j][k + 1] - 2.0 * A[i][j][k] + A[i][j][k - 1]) + A[i][j][k];
          }
        }
      }
      
      
      for (i = 1; i < 20 - 1; i++) {
        
        
        for (j = 1; j < 20 - 1; j++) {
          for (k = 1; k < 20 - 1; k++) {
            A[i][j][k] = 0.125 * (B[i + 1][j][k] - 2.0 * B[i][j][k] + B[i - 1][j][k]) + 0.125 * (B[i][j + 1][k] - 2.0 * B[i][j][k] + B[i][j - 1][k]) + 0.125 * (B[i][j][k + 1] - 2.0 * B[i][j][k] + B[i][j][k - 1]) + B[i][j][k];
          }
        }
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:

```c
void kernel_heat_3d(int tsteps,int n,float A[20][20][20],float B[20][20][20])
{
    #pragma HLS interface m_axi port=A[0] dim=2
    #pragma HLS interface m_axi port=B[0] dim=2

    int t;
    int i;
    int j;
    int k;

    for (t = 1; t <= 40; t++) {
        #pragma HLS loop_tripcount min=40 max=40
        #pragma HLS pipeline II=1

        for (i = 1; i < 20 - 1; i++) {
            #pragma HLS loop_tripcount min=19 max=19
            #pragma HLS pipeline II=1

            for (j = 1; j < 20 - 1; j++) {
                #pragma HLS loop_tripcount min=19 max=19
                #pragma HLS pipeline II=1

                for (k = 1; k < 20 - 1; k++) {
                    #pragma HLS pipeline II=1
                    B[i][j][k] = 0.125 * (A[i + 1][j][k] - 2.0 * A[i][j][k] + A[i - 1][j][k]) + 0.125 * (A[i][j + 1][k] - 2.0 * A[i][j][k] + A[i][j - 1][k]) + 0.125 * (A[i][j][k + 1] - 2.0 * A[i][j][k] + A[i][j][k - 1]) + A[i][j][k];
                }
            }
        }

        for (i = 1; i < 20 - 1; i++) {
            #pragma HLS loop_tripcount min=19 max=19
            #pragma HLS pipeline II=1

            for (j = 1; j < 20 - 1; j++) {
                #pragma HLS loop_tripcount min=19 max=19
                #pragma HLS pipeline II=1

                for (k = 1; k < 20 - 1; k++) {
                    #pragma HLS pipeline II=1
                    A[i][j][k] = 0.125 * (B[i + 1][j][k] - 2.0 * B[i][j][k] + B[i - 1][j][k]) + 0.125 * (B[i][j + 1][k] - 2.0 * B[i][j][k] + B[i][j - 1][k]) + 0.125 * (B[i][j][k + 1] - 2.0 * B[i][j][k] + B[i][j][k - 1]) + B[i][j][k];
                }
            }
        }
    }
}
```

The HLS pragmas used are:

* `#pragma HLS interface m_axi port=A[0] dim=2` and `#pragma HLS interface m_axi port=B[0] dim=2` to specify the interface for the AXI memory-mapped ports.
* `#pragma HLS loop_tripcount min=40 max=40` to specify the trip count for the outer loop.
* `#pragma HLS pipeline II=1` to specify the pipeline depth for each loop.
* `#pragma HLS loop_tripcount min=19 max=19` to specify the trip count for the inner loops.
* `#pragma HLS pipeline II=1` to specify the pipeline depth for each inner loop.

Note that the `#pragma HLS` directives should be placed at the beginning of each loop or function to specify the optimization directives.