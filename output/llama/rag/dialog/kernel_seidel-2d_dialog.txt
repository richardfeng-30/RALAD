=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
int N2 = SIZE2; // N2=N>>1
bit reverse(X R, X I);
step = N2;
DTYPE a, e, c, s;
stage loop:
for (stage = 1; stage <= M; stage++) {
// Do M stages of butterflies
DFTpts = 1 << stage;
// DFT = 2ˆstage = points in sub DFT
numBF = DFTpts / 2;
// Butterfly WIDTHS in sub−DFT
k = 0;
e = −6.283185307178 / DFTpts;
a = 0.0;
// Perform butterflies for j−th stage
butterfly loop:
for (j = 0; j < numBF; j++) {
c = cos(a);
s = sin(a);
a = a + e;
// Compute butterflies that use same W∗∗k
dft loop:

Example 2: 
for (i = N − 1; i > 0; i−−) {
shift reg[i] = shift reg[i − 1];
}
shift reg[0] = x;
acc = 0;
MAC:

Example 3: 
if (i == 1) {
shift reg[1] = shift reg[0];
}
shift reg[0] = x;
Figure 2.5: Manually unrolling the TDL loop in the fir11 function.

Optimize the following code by inserting pragma HLS lines.
void kernel_seidel_2d(int tsteps,int n,float A[120][120])
{
  int t;
  int i;
  int j;
{
    
    
    
    for (t = 0; t <= 40 - 1; t++) {
      
      
      
      for (i = 1; i <= 120 - 2; i++) {
        
        for (j = 1; j <= 120 - 2; j++) {
          A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;
        }
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:
```c
void kernel_seidel_2d(int tsteps, int n, float A[120][120]) {
  #pragma HLS INTERFACE m_axi port=A[0] depth=14400
  #pragma HLS INTERFACE s_axilite port=tsteps
  #pragma HLS INTERFACE s_axilite port=n
  #pragma HLS INTERFACE s_axilite port=A

  int t;
  int i;
  int j;
  #pragma HLS DATAFLOW

  for (t = 0; t <= 40 - 1; t++) {
    #pragma HLS LOOP_TRIPCOUNT min=1 max=40
    #pragma HLS UNROLL factor=4

    for (i = 1; i <= 120 - 2; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=1 max=119
      #pragma HLS UNROLL factor=4

      for (j = 1; j <= 120 - 2; j++) {
        #pragma HLS LOOP_TRIPCOUNT min=1 max=119
        #pragma HLS UNROLL factor=4

        A[i][j] = (A[i - 1][j - 1] + A[i - 1][j] + A[i - 1][j + 1] + A[i][j - 1] + A[i][j] + A[i][j + 1] + A[i + 1][j - 1] + A[i + 1][j] + A[i + 1][j + 1]) / 9.0;
      }
    }
  }
}
```
Here's what each pragma does:

* `#pragma HLS INTERFACE`: specifies the interface between the kernel and the external memory.
* `#pragma HLS DATAFLOW`: indicates that the kernel is a dataflow kernel, which allows the compiler to optimize the code for pipelining and parallelism.
* `#pragma HLS LOOP_TRIPCOUNT`: specifies the minimum and maximum number of iterations for a loop, which helps the compiler optimize the loop.
* `#pragma HLS UNROLL`: specifies the unrolling factor for a loop, which can improve the performance of the kernel.

Note that the unrolling factor is set to 4, which means that the innermost loop will be unrolled 4 times. This can improve the performance of the kernel by reducing the number of loop iterations and increasing the amount of parallelism. However, the optimal unrolling factor may depend on the specific hardware and the size of the input data.