=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
int N2 = SIZE2; // N2=N>>1
bit reverse(X R, X I);
step = N2;
DTYPE a, e, c, s;
stage loop:
for (stage = 1; stage <= M; stage++) {
// Do M stages of butterflies
DFTpts = 1 << stage;
// DFT = 2ˆstage = points in sub DFT
numBF = DFTpts / 2;
// Butterfly WIDTHS in sub−DFT
k = 0;
e = −6.283185307178 / DFTpts;
a = 0.0;
// Perform butterflies for j−th stage
butterfly loop:
for (j = 0; j < numBF; j++) {
c = cos(a);
s = sin(a);
a = a + e;
// Compute butterflies that use same W∗∗k
dft loop:

Example 2: 
void firI1(data t ∗y, data t x);
void firQ1(data t ∗y, data t x);
void firI2(data t ∗y, data t x);
void firQ2(data t ∗y, data t x);

Example 3: 
int i;
acc = 0;
Shift Accum Loop:
for (i = N − 1; i >= 0; i−−) {

Optimize the following code by inserting pragma HLS lines.
void kernel_jacobi_1d(int tsteps,int n,float A[120],float B[120])
{
  int t;
  int i;
{
    
    
    
    for (t = 0; t < 40; t++) {
      
      for (i = 1; i < 120 - 1; i++) {
        B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);
      }
      
      for (i = 1; i < 120 - 1; i++) {
        A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized C code with HLS pragmas:

```c
void kernel_jacobi_1d(int tsteps, int n, float A[120], float B[120]) {
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem
  #pragma HLS INTERFACE s_axli port=tsteps
  #pragma HLS INTERFACE s_axli port=n
  #pragma HLS INTERFACE s_axlo port=A
  #pragma HLS INTERFACE s_axlo port=B
  #pragma HLS INTERFACE s_axlo port=s_ax
  #pragma HLS DATAFLOW

  int t;
  int i;

  #pragma HLS DATAFLOW
  ShiftAccumLoop:
  for (t = 0; t < 40; t++) {
    #pragma HLS LOOP_TRIPCOUNT min=40 max=40
    #pragma HLS UNROLL factor=1
    for (i = 1; i < 120 - 1; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=119 max=119
      #pragma HLS UNROLL factor=1
      B[i] = 0.33333 * (A[i - 1] + A[i] + A[i + 1]);
    }
    #pragma HLS DATAFLOW
    ShiftAccumLoop2:
    for (i = 1; i < 120 - 1; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=119 max=119
      #pragma HLS UNROLL factor=1
      A[i] = 0.33333 * (B[i - 1] + B[i] + B[i + 1]);
    }
  }
}
```

In this code, I added the following HLS pragmas:

* `#pragma HLS INTERFACE` directives to specify the interfaces for the function, including memory-mapped interfaces for the arrays A and B, and scalar interfaces for the integer variables tsteps and n.
* `#pragma HLS DATAFLOW` directives to specify that the function consists of a dataflow of operations.
* `#pragma HLS LOOP_TRIPCOUNT` directives to specify the minimum and maximum trip counts for each loop.
* `#pragma HLS UNROLL` directives to specify the unrolling factor for each loop.
* `#pragma HLS DATAFLOW` directives to separate the two loops into separate dataflow regions.

These pragmas can help the HLS compiler to optimize the code for performance, area, and power consumption.