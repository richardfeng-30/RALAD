=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
G[k] =

X
n=0

g[2n] · e

−j2πkn
N/2

N/2−1

+

X
n=0

103

g[2n + 1] · e

−j2πk(2n)
N

·e

−j2πk
N

(5.15)

FAST FOURIER TRANSFORM

In the first summation (even inputs), we simply move the 2 into the denominator so that it is
now N/2. The second summation (odd inputs) uses the power rule to separate the +1 leaving two
complex exponentials. We can further modify this equation to
N/2−1

G[k] =

X

N/2−1

−j2πkn

g[2n] · e N/2 + e

−j2πk
N

·

n=0

X

−j2πkn

g[2n + 1] · e N/2

(5.16)

n=0

Here we only modify the second summation. First we pull one of the complex exponentials outside
of the summation since it does not depend upon n. And we also move the 2 into the denominator
as we did before in the first summation. Note that both summations now have the same complex
−j2πkn

exponential e N/2 . Finally, we simplify this to
G[k] = Ak + WNk Bk

(5.17)

Example 2: 
n−1
Y

Ki =

i=0

n−1
Y
i=0

√

1
1 + 2−2i

(3.24)

and
K = lim K(n) ≈ 0.6072529350088812561694
n→∞

(3.25)

The scaling factors for different iterations can be calculated in advance and stored in a table. If we
always perform a fixed number of rotations, this is simply one constant. This correction could also
be made in advance by scaling v0 appropriately before performing the rotations. Sometimes it is
ok to ignore this scaling, which results in a processing gain
n−1

A=

Yp
1
= lim
1 + 2−2i ≈ 1.64676025812107
n→∞
K

(3.26)

i=0

Example 3: 
for (i = N − 1; i > 0; i−−) {
shift reg[i] = shift reg[i − 1];
}
shift reg[0] = x;
acc = 0;
MAC:

Optimize the following code by inserting pragma HLS lines.

void kernel_durbin(int n,float r[120],float y[120])
{
  float z[120];
  float alpha;
  float beta;
  float sum;
  int i;
  int k;
{
    y[0] = -r[0];
    beta = 1.0;
    alpha = -r[0];
    
    
    
    for (k = 1; k < 120; k++) {
      beta = (((float )1) - alpha * alpha) * beta;
      sum = 0.0;
      for (i = 0; i < k; i++) {
        sum += r[k - i - 1] * y[i];
      }
      alpha = -(r[k] + sum) / beta;
      for (i = 0; i < k; i++) {
        z[i] = y[i] + alpha * y[k - i - 1];
      }
      for (i = 0; i < k; i++) {
        y[i] = z[i];
      }
      y[k] = alpha;
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized C code with HLS pragmas:

```c
void kernel_durbin(int n, float r[120], float y[120]) {
  #pragma HLS INTERFACE m_axi port=r offset=slave
  #pragma HLS INTERFACE m_axi port=y offset=slave
  #pragma HLS INTERFACE s_axilite port=n
  #pragma HLS INTERFACE s_axilite port=return

  float z[120];
  float alpha;
  float beta;
  float sum;
  int i;
  int k;

  #pragma HLS DATAFLOW
  #pragma HLS DATA_REORDER

  y[0] = -r[0];
  beta = 1.0;
  alpha = -r[0];

  #pragma HLS LOOP_FLATTEN
  for (k = 1; k < 120; k++) {
    #pragma HLS UNROLL
    beta = (((float)1) - alpha * alpha) * beta;
    sum = 0.0;
    #pragma HLS LOOP_FLATTEN
    for (i = 0; i < k; i++) {
      sum += r[k - i - 1] * y[i];
    }
    alpha = -(r[k] + sum) / beta;
    #pragma HLS LOOP_FLATTEN
    for (i = 0; i < k; i++) {
      z[i] = y[i] + alpha * y[k - i - 1];
    }
    #pragma HLS LOOP_FLATTEN
    for (i = 0; i < k; i++) {
      y[i] = z[i];
    }
    y[k] = alpha;
  }
}
```

Explanation:

1.  We added HLS pragmas for interfaces (m_axi and s_axilite) to define the memory and AXI interfaces for the kernel.
2.  We used the `DATAFLOW` directive to indicate that the kernel is a dataflow-oriented design, which can help the HLS compiler to optimize the code.
3.  We used the `DATA_REORDER` directive to reorder the data to improve memory access patterns.
4.  We used the `LOOP_FLATTEN` directive to flatten the loops, which can help to reduce the number of iterations and improve the performance.
5.  We used the `UNROLL` directive to unroll the inner loop, which can help to reduce the number of iterations and improve the performance.

Note: The HLS pragmas are specific to the Xilinx Vivado HLS compiler. The syntax and directives may vary depending on the HLS compiler used.