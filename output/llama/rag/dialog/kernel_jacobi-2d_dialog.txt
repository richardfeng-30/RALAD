=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
int N2 = SIZE2; // N2=N>>1
bit reverse(X R, X I);
step = N2;
DTYPE a, e, c, s;
stage loop:
for (stage = 1; stage <= M; stage++) {
// Do M stages of butterflies
DFTpts = 1 << stage;
// DFT = 2ˆstage = points in sub DFT
numBF = DFTpts / 2;
// Butterfly WIDTHS in sub−DFT
k = 0;
e = −6.283185307178 / DFTpts;
a = 0.0;
// Perform butterflies for j−th stage
butterfly loop:
for (j = 0; j < numBF; j++) {
c = cos(a);
s = sin(a);
a = a + e;
// Compute butterflies that use same W∗∗k
dft loop:

Example 2: 
void firI1(data t ∗y, data t x);
void firQ1(data t ∗y, data t x);
void firI2(data t ∗y, data t x);
void firQ2(data t ∗y, data t x);

Example 3: 
int ABij = 0;
product: for(int k = 0; k < M; ++k) {
ABij += A[i][k] ∗ B[k][j];
}
AB[i][j] = ABij;
}
}
}
Figure 7.1: A common three for loop structure for matrix multiplication. The outer for loops,
labeled rows and cols, iterate across the rows and columns of the output matrix AB. The innermost
loop, labeled product multiplies the appropriate elements of one row of A and one column of B and
accumulates them until it has the result for the element in AB .
Matrix multiplication is a fundamental operation in numerical algorithms. Computing the
product between large matrices can take a significant amount of time. Therefore, it is critically
important part of many of problems in numerical computing. Fundamentally, matrices represent linear transforms between vector spaces; matrix multiplication provides way to compose the
linear transforms. Applications include linearly changing coordinates (e.g., translation, rotation

Optimize the following code by inserting pragma HLS lines.
void kernel_jacobi_2d(int tsteps,int n,float A[90][90],float B[90][90])
{
  int t;
  int i;
  int j;
{
    
    
    
    for (t = 0; t < 40; t++) {
      
      
      
      for (i = 1; i < 90 - 1; i++) {
        
        for (j = 1; j < 90 - 1; j++) {
          B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);
        }
      }
      
      
      
      for (i = 1; i < 90 - 1; i++) {
        
        for (j = 1; j < 90 - 1; j++) {
          A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);
        }
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:
```c
void kernel_jacobi_2d(int tsteps, int n, float A[90][90], float B[90][90]) {
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem
  #pragma HLS INTERFACE s_axilite port=tsteps
  #pragma HLS INTERFACE s_axilite port=n
  #pragma HLS INTERFACE s_axilite port=A
  #pragma HLS INTERFACE s_axilite port=B

  #pragma HLS DATAFLOW

  int t;
  int i;
  int j;

  for (t = 0; t < 40; t++) {
    #pragma HLS LOOP_TRIPCOUNT min=40 max=40
    #pragma HLS UNROLL factor=1

    for (i = 1; i < 90 - 1; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=88 max=88
      #pragma HLS UNROLL factor=1

      for (j = 1; j < 90 - 1; j++) {
        #pragma HLS LOOP_TRIPCOUNT min=88 max=88
        #pragma HLS UNROLL factor=1

        B[i][j] = 0.2 * (A[i][j] + A[i][j - 1] + A[i][1 + j] + A[1 + i][j] + A[i - 1][j]);
      }
    }

    for (i = 1; i < 90 - 1; i++) {
      #pragma HLS LOOP_TRIPCOUNT min=88 max=88
      #pragma HLS UNROLL factor=1

      for (j = 1; j < 90 - 1; j++) {
        #pragma HLS LOOP_TRIPCOUNT min=88 max=88
        #pragma HLS UNROLL factor=1

        A[i][j] = 0.2 * (B[i][j] + B[i][j - 1] + B[i][1 + j] + B[1 + i][j] + B[i - 1][j]);
      }
    }
  }
}
```
The HLS pragmas inserted are:

* `#pragma HLS INTERFACE m_axi`: specifies the AXI interfaces for the input/output ports.
* `#pragma HLS INTERFACE s_axilite`: specifies the AXI-Lite interfaces for the input/output ports.
* `#pragma HLS DATAFLOW`: specifies that the function is a dataflow program.
* `#pragma HLS LOOP_TRIPCOUNT`: specifies the minimum and maximum trip count for the loops.
* `#pragma HLS UNROLL`: specifies the unroll factor for the loops.

These pragmas can help the HLS compiler to optimize the code for performance and resource utilization.