=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
N
−1
X

g[n] · e

−j2πkn
N

Example 2: 
int ABij = 0;
product: for(int k = 0; k < M; ++k) {
ABij += A[i][k] ∗ B[k][j];
}
AB[i][j] = ABij;
}
}
}
Figure 7.1: A common three for loop structure for matrix multiplication. The outer for loops,
labeled rows and cols, iterate across the rows and columns of the output matrix AB. The innermost
loop, labeled product multiplies the appropriate elements of one row of A and one column of B and
accumulates them until it has the result for the element in AB .
Matrix multiplication is a fundamental operation in numerical algorithms. Computing the
product between large matrices can take a significant amount of time. Therefore, it is critically
important part of many of problems in numerical computing. Fundamentally, matrices represent linear transforms between vector spaces; matrix multiplication provides way to compose the
linear transforms. Applications include linearly changing coordinates (e.g., translation, rotation

Example 3: 
G[k] =

X
n=0

g[2n] · e

−j2πkn
N/2

N/2−1

+

X
n=0

103

g[2n + 1] · e

−j2πk(2n)
N

·e

−j2πk
N

(5.15)

FAST FOURIER TRANSFORM

In the first summation (even inputs), we simply move the 2 into the denominator so that it is
now N/2. The second summation (odd inputs) uses the power rule to separate the +1 leaving two
complex exponentials. We can further modify this equation to
N/2−1

G[k] =

X

N/2−1

−j2πkn

g[2n] · e N/2 + e

−j2πk
N

·

n=0

X

−j2πkn

g[2n + 1] · e N/2

(5.16)

n=0

Here we only modify the second summation. First we pull one of the complex exponentials outside
of the summation since it does not depend upon n. And we also move the 2 into the denominator
as we did before in the first summation. Note that both summations now have the same complex
−j2πkn

exponential e N/2 . Finally, we simplify this to
G[k] = Ak + WNk Bk

(5.17)

Optimize the following code by inserting pragma HLS lines.

void kernel_bicg(int m,int n,float A[124][116],float s[116],float q[124],float p[116],float r[124])
{
  int i;
  int j;
{
    
    for (i = 0; i < 116; i++) {
      s[i] = ((float )0);
    }
    
    
    
    for (i = 0; i < 124; i++) {
      q[i] = 0.0;
      
      for (j = 0; j < 116; j++) {
        s[j] = s[j] + r[i] * A[i][j];
        q[i] = q[i] + A[i][j] * p[j];
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:

```c
void kernel_bicg(int m,int n,float A[124][116],float s[116],float q[124],float p[116],float r[124])
{
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=s offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=q offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=p offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=r offset=slave bundle=gmem
  #pragma HLS INTERFACE s_axli port=m
  #pragma HLS INTERFACE s_axli port=n
  #pragma HLS INTERFACE s_axli port=return

  #pragma HLS DATAFLOW

  int i;
  int j;

  #pragma HLS LOOP_FLATTEN off

  #pragma HLS LOOP_TRIPCOUNT min=116 max=116

  for (i = 0; i < 116; i++) {
    s[i] = ((float )0);
  }

  #pragma HLS LOOP_FLATTEN off

  #pragma HLS LOOP_TRIPCOUNT min=124 max=124

  for (i = 0; i < 124; i++) {
    q[i] = 0.0;

    #pragma HLS LOOP_FLATTEN off

    #pragma HLS LOOP_TRIPCOUNT min=116 max=116

    for (j = 0; j < 116; j++) {
      s[j] = s[j] + r[i] * A[i][j];
      q[i] = q[i] + A[i][j] * p[j];
    }
  }
}
```

In this code, I've added the following HLS pragmas:

* `#pragma HLS INTERFACE m_axi` to specify the interfaces for the AXI memory-mapped I/O operations.
* `#pragma HLS DATAFLOW` to specify that the code is a dataflow program.
* `#pragma HLS LOOP_FLATTEN` to specify that the loops should be flattened.
* `#pragma HLS LOOP_TRIPCOUNT` to specify the minimum and maximum trip counts for each loop.
* `#pragma HLS LOOP_FLATTEN off` to specify that the loops should not be flattened.
* `#pragma HLS LOOP_TRIPCOUNT min=116 max=116` to specify the minimum and maximum trip counts for each loop.

These pragmas can help the HLS compiler to optimize the code for better performance and resource utilization.