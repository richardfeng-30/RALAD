=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
N
−1
X

g[n] · e

−j2πkn
N

Example 2: 
for computation. Larger FPGAs can have millions of these programmable logic elements.
How would you program the 2-LUT from Figure 1.1 to implement an XOR gate? An OR
gate? How many programming bits does an n input (n-LUT) require?

Example 3: 
G[k] =

X
n=0

g[2n] · e

−j2πkn
N/2

N/2−1

+

X
n=0

103

g[2n + 1] · e

−j2πk(2n)
N

·e

−j2πk
N

(5.15)

FAST FOURIER TRANSFORM

In the first summation (even inputs), we simply move the 2 into the denominator so that it is
now N/2. The second summation (odd inputs) uses the power rule to separate the +1 leaving two
complex exponentials. We can further modify this equation to
N/2−1

G[k] =

X

N/2−1

−j2πkn

g[2n] · e N/2 + e

−j2πk
N

·

n=0

X

−j2πkn

g[2n + 1] · e N/2

(5.16)

n=0

Here we only modify the second summation. First we pull one of the complex exponentials outside
of the summation since it does not depend upon n. And we also move the 2 into the denominator
as we did before in the first summation. Note that both summations now have the same complex
−j2πkn

exponential e N/2 . Finally, we simplify this to
G[k] = Ak + WNk Bk

(5.17)

Optimize the following code by inserting pragma HLS lines.

void kernel_2mm(int ni,int nj,int nk,int nl,float alpha,float beta,float tmp[40][50],float A[40][70],float B[70][50],float C[50][80],float D[40][80])
{
  int i;
  int j;
  int k;
{
    
    
    
    for (i = 0; i < 40; i++) {
      
      
      
      for (j = 0; j < 50; j++) {
        tmp[i][j] = 0.0;
        
        for (k = 0; k < 70; ++k) {
          tmp[i][j] += alpha * A[i][k] * B[k][j];
        }
      }
    }
    
    
    
    for (i = 0; i < 40; i++) {
      
      
      
      for (j = 0; j < 80; j++) {
        D[i][j] *= beta;
        
        for (k = 0; k < 50; ++k) {
          D[i][j] += tmp[i][k] * C[k][j];
        }
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:
```
void kernel_2mm(int ni,int nj,int nk,int nl,float alpha,float beta,float tmp[40][50],float A[40][70],float B[70][50],float C[50][80],float D[40][80])
{
  #pragma HLS INTERFACE m_axi port=tmp offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=C offset=slave bundle=gmem
  #pragma HLS INTERFACE m_axi port=D offset=slave bundle=gmem

  #pragma HLS INTERFACE s_axilite port=ni
  #pragma HLS INTERFACE s_axilite port=nj
  #pragma HLS INTERFACE s_axilite port=nk
  #pragma HLS INTERFACE s_axilite port=nl
  #pragma HLS INTERFACE s_axilite port=alpha
  #pragma HLS INTERFACE s_axilite port=beta

  #pragma HLS DATAFLOW

  #pragma HLS LOOP_TRIPCOUNT min=40 max=40
  #pragma HLS LOOP_TRIPCOUNT min=50 max=50
  #pragma HLS LOOP_TRIPCOUNT min=70 max=70
  #pragma HLS LOOP_TRIPCOUNT min=50 max=50
  #pragma HLS LOOP_TRIPCOUNT min=80 max=80

  int i;
  int j;
  int k;

  #pragma HLS PIPELINE II=1
  for (i = 0; i < 40; i++) {
    #pragma HLS LOOP_UNROLL
    for (j = 0; j < 50; j++) {
      tmp[i][j] = 0.0;
      #pragma HLS UNROLL
      for (k = 0; k < 70; ++k) {
        tmp[i][j] += alpha * A[i][k] * B[k][j];
      }
    }
  }

  #pragma HLS PIPELINE II=1
  for (i = 0; i < 40; i++) {
    #pragma HLS LOOP_UNROLL
    for (j = 0; j < 80; j++) {
      D[i][j] *= beta;
      #pragma HLS UNROLL
      for (k = 0; k < 50; ++k) {
        D[i][j] += tmp[i][k] * C[k][j];
      }
    }
  }
}
```
Note that I added the following pragmas:

* `#pragma HLS INTERFACE` to specify the memory interface and AXI-lite interface for the input and output arrays.
* `#pragma HLS DATAFLOW` to specify that the function is a dataflow function, which allows the compiler to optimize the dataflow graph.
* `#pragma HLS LOOP_TRIPCOUNT` to specify the minimum and maximum number of iterations for each loop.
* `#pragma HLS PIPELINE` to specify the pipeline II (iteration interval) for each loop.
* `#pragma HLS LOOP_UNROLL` to specify that the loop should be unrolled to improve performance.
* `#pragma HLS UNROLL` to specify that the inner loop should be unrolled to improve performance.

These pragmas can help the compiler optimize the code for performance and resource utilization.