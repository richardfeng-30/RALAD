=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
implementation. IEEE Transactions on Computers, 42(2):168–178, 1993.
[25] Brian P. Flannery, William H. Press, Saul A. Teukolsky, and William Vetterling. Numerical
recipes in C. Press Syndicate of the University of Cambridge, New York, 1992.
[26] Daniel D. Gajski, Nikil D. Dutt, Allen C.H. Wu, and Steve Y.L. Lin. High-Level Synthesis:
Introduction to Chip and System Design. Springer Science & Business Media, 2012.
[27] W Morven Gentleman and Gordon Sande. Fast fourier transforms: for fun and profit. In
Proceedings of the November 7-10, 1966, fall joint computer conference, pages 563–578. ACM,
1966.
226

Example 2: 
N
−1
X

g[n] · e

−j2πkn
N

Example 3: 
for computation. Larger FPGAs can have millions of these programmable logic elements.
How would you program the 2-LUT from Figure 1.1 to implement an XOR gate? An OR
gate? How many programming bits does an n input (n-LUT) require?

Optimize the following code by inserting pragma HLS lines.

void kernel_doitgen(int nr,int nq,int np,float A[25][20][30],float C4[30][30],float sum[30])
{
  int r;
  int q;
  int p;
  int s;
{
    
    
    for (r = 0; r < 25; r++) {
      
      
      for (q = 0; q < 20; q++) {
        
        
        for (p = 0; p < 30; p++) {
          sum[p] = 0.0;
          for (s = 0; s < 30; s++) {
            sum[p] += A[r][q][s] * C4[s][p];
          }
        }
        for (p = 0; p < 30; p++) {
          A[r][q][p] = sum[p];
        }
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:
```c
void kernel_doitgen(int nr, int nq, int np, float A[25][20][30], float C4[30][30], float sum[30])
{
  #pragma HLS interface m_axi port=A[0] dim=2
  #pragma HLS interface m_axi port=C4[0] dim=2
  #pragma HLS interface m_axi port=sum[0] dim=1
  
  int r;
  int q;
  int p;
  int s;
  
  #pragma HLS dataflow
  #pragma HLS pipeline II=25
  
  for (r = 0; r < 25; r++) {
    #pragma HLS loop_tripcount 25
    #pragma HLS pipeline II=20
    
    for (q = 0; q < 20; q++) {
      #pragma HLS loop_tripcount 20
      #pragma HLS pipeline II=30
      
      for (p = 0; p < 30; p++) {
        sum[p] = 0.0;
        #pragma HLS unroll
        for (s = 0; s < 30; s++) {
          sum[p] += A[r][q][s] * C4[s][p];
        }
      }
      #pragma HLS pipeline II=30
      
      for (p = 0; p < 30; p++) {
        A[r][q][p] = sum[p];
      }
    }
  }
}
```
Here's a brief explanation of the HLS pragmas used:

* `#pragma HLS interface m_axi`: specifies the memory interface for the AXI4-Stream interface.
* `#pragma HLS dataflow`: specifies that the kernel is a dataflow-oriented kernel, which can improve performance.
* `#pragma HLS pipeline II=<n>`: specifies the pipeline depth for the innermost loop. In this case, we've set it to 25 for the outermost loop, 20 for the middle loop, and 30 for the innermost loop.
* `#pragma HLS loop_tripcount <n>`: specifies the estimated number of iterations for the loop. This can help the HLS compiler optimize the loop.
* `#pragma HLS unroll`: specifies that the inner loop should be unrolled. This can improve performance by reducing the number of loop iterations.

Note that the exact pragmas used may vary depending on the specific requirements of your design and the capabilities of your HLS tool.