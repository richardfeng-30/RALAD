=== SYSTEM ===
Always answer with optimized C code including HLS pragmas. Add appropriate #pragma HLS directives for interfaces, loops, and memory optimization.

=== USER QUERY ===
You are given some HLS pragma insertion examples.

Example 1: 
for (i = N − 1; i > 0; i−−) {
shift reg[i] = shift reg[i − 1];
}
shift reg[0] = x;
acc = 0;
MAC:

Example 2: 
int wi, wj;
if (i < 1 − outrow) wi = 1 − outrow;
else if (i >= MAX HEIGHT − outrow + 1) wi = MAX HEIGHT − outrow;
else wi = i;

Example 3: 
void spmv(int rowPtr[NUM ROWS+1], int columnIndex[NNZ],
DTYPE values[NNZ], DTYPE y[SIZE], DTYPE x[SIZE])
{
L1: for (int i = 0; i < NUM ROWS; i++) {
DTYPE y0 = 0;
L2: for (int k = rowPtr[i]; k < rowPtr[i+1]; k++) {
#pragma HLS unroll factor=8
#pragma HLS pipeline
y0 += values[k] ∗ x[columnIndex[k]];
}
y[i] = y0;
}
}
Figure 6.2: The baseline code for sparse matrix vector (SpMV) multiplication, which performs the
operation y = M · x. The variables rowPtr, columnIndex, and values hold M in CRS format. The
first for loop iterates across the rows while the second nested for loop iterates across the columns
of M by multiplying each non-zero element by the corresponding element in the vector x which
results in one element in the resulting vector y.

Optimize the following code by inserting pragma HLS lines.

void kernel_floyd_warshall(int n,int path[180][180])
{
  int i;
  int j;
  int k;
{
    
    
    
    for (k = 0; k < 180; k++) {
      
      
      
      for (i = 0; i < 180; i++) {
        
        for (j = 0; j < 180; j++) {
          path[i][j] = (path[i][j] < path[i][k] + path[k][j]?path[i][j] : path[i][k] + path[k][j]);
        }
      }
    }
  }
}


=== LLAMA RESPONSE ===
Here is the optimized code with HLS pragmas:

```c
void kernel_floyd_warshall(int n, int path[180][180]) {
  #pragma HLS interface m_axi port = path[0] bundle = s_axi
  #pragma HLS dataflow
  
  int i;
  int j;
  int k;
  
  {
    #pragma HLS loop_tripcount min = 1 max = 180
    for (k = 0; k < 180; k++) {
      
      #pragma HLS loop_tripcount min = 1 max = 180
      for (i = 0; i < 180; i++) {
        
        #pragma HLS loop_tripcount min = 1 max = 180
        for (j = 0; j < 180; j++) {
          path[i][j] = (path[i][j] < path[i][k] + path[k][j]?path[i][j] : path[i][k] + path[k][j]);
        }
      }
    }
  }
}
```

Explanation of the HLS pragmas used:

1. `#pragma HLS interface m_axi port = path[0] bundle = s_axi`: This directive specifies the interface for the path array. In this case, it is an AXI4-Lite interface.

2. `#pragma HLS dataflow`: This directive specifies that the function should be implemented as a dataflow graph. This is a good choice for this function because it has a pipeline structure.

3. `#pragma HLS loop_tripcount min = 1 max = 180` for each loop: This directive specifies the trip count for each loop. The trip count is the number of iterations of the loop. In this case, the trip count is specified as 1 to 180, which is the range of the loop variables.

Note that the HLS pragmas are used to guide the compiler in generating efficient hardware implementations. The actual code generation may vary depending on the specific compiler and target hardware.