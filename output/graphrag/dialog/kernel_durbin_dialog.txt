### Summary of Relevant Optimization Strategies and Pragmas for HLS

To optimize the given kernel function `kernel_durbin` for performance while controlling resource utilization and compilation time, several High-Level Synthesis (HLS) optimization strategies and pragmas can be applied:

1. **Loop Unrolling (`#pragma HLS UNROLL`)**  
   Unrolling loops increases parallelism by replicating the loop body multiple times, allowing concurrent execution of iterations. This can significantly improve throughput but may increase resource usage. Partial unrolling with a factor can balance performance and resource utilization [Data: Entities (3228, 4422)].

2. **Loop Pipelining (`#pragma HLS PIPELINE`)**  
   Pipelining overlaps the execution of loop iterations, improving throughput without fully replicating the loop body. It is a common and effective optimization for loops with dependencies [Data: Entities (4955, 4139)].

3. **Array Partitioning (`#pragma HLS ARRAY_PARTITION`)**  
   Partitioning arrays into smaller blocks or individual elements enables concurrent access to multiple elements, reducing memory bottlenecks and improving loop performance [Data: Entities (4955, 4139)].

4. **Interface Pragmas (`#pragma HLS INTERFACE`)**  
   Specifying interfaces for function arguments (e.g., AXI interfaces) can improve data transfer efficiency between the kernel and external memory [Data: Entities (357, 440)].

5. **Optimization Directives**  
   Applying optimization directives at the function or loop level can guide the synthesis tool to meet performance targets while balancing resource usage [Data: Entities (213, 303)].

6. **Code Restructuring**  
   Restructuring code to reduce dependencies and improve data locality can enhance the effectiveness of pragmas and overall performance [Data: Entities (4626, 6263)].

### Applying Pragmas to `kernel_durbin`

Given the nested loops and data dependencies in `kernel_durbin`, the following approach is recommended:

- **Pipeline the outer loop (`k` loop)** to improve throughput by overlapping iterations.
- **Partially unroll the inner loops (`i` loops)** with a factor that balances resource usage and performance.
- **Partition arrays `y` and `z`** to enable concurrent access during the inner loops.
- **Specify the interface pragmas** for the input and output arrays to optimize data transfer.

### Final Optimized Code with Pragmas

```c
void kernel_durbin(int n, float r[120], float y[120]) {
#pragma HLS INTERFACE m_axi port=r offset=slave bundle=gmem
#pragma HLS INTERFACE m_axi port=y offset=slave bundle=gmem
#pragma HLS INTERFACE s_axilite port=n bundle=control
#pragma HLS INTERFACE s_axilite port=r bundle=control
#pragma HLS INTERFACE s_axilite port=y bundle=control
#pragma HLS INTERFACE s_axilite port=return bundle=control

    float z[120];
#pragma HLS ARRAY_PARTITION variable=y complete dim=1
#pragma HLS ARRAY_PARTITION variable=z complete dim=1

    float alpha;
    float beta;
    float sum;
    int i;
    int k;

    y[0] = -r[0];
    beta = 1.0;
    alpha = -r[0];

    // Pipeline the outer loop to improve throughput
    for (k = 1; k < 120; k++) {
#pragma HLS PIPELINE II=1

        beta = (1.0f - alpha * alpha) * beta;
        sum = 0.0f;

        // Partially unroll the inner loop to balance resource usage and performance
        for (i = 0; i < k; i++) {
#pragma HLS UNROLL factor=4
            sum += r[k - i - 1] * y[i];
        }

        alpha = -(r[k] + sum) / beta;

        for (i = 0; i < k; i++) {
#pragma HLS UNROLL factor=4
            z[i] = y[i] + alpha * y[k - i - 1];
        }

        for (i = 0; i < k; i++) {
#pragma HLS UNROLL factor=4
            y[i] = z[i];
        }

        y[k] = alpha;
    }
}
```

### Explanation

- **Interface Pragmas**: The `m_axi` pragmas specify AXI master interfaces for arrays `r` and `y`, enabling efficient memory access. The `s_axilite` pragmas provide control interfaces for kernel arguments and return [Data: Entities (357, 440)].
- **Array Partitioning**: Complete partitioning of arrays `y` and `z` allows simultaneous access to all elements, which is critical for unrolling inner loops and avoiding memory access bottlenecks [Data: Entities (4955, 4139)].
- **Loop Pipelining**: The outer loop `k` is pipelined with an initiation interval (II) of 1, aiming to start a new iteration every clock cycle, maximizing throughput [Data: Entities (4955, 4139)].
- **Loop Unrolling**: Inner loops are partially unrolled with a factor of 4 to increase parallelism without excessive resource usage. The factor can be tuned based on synthesis results to keep resource utilization under 80% and compilation time reasonable [Data: Entities (3228, 4422)].

This combination of pragmas and code restructuring should significantly improve the performance of the `kernel_durbin` function while respecting resource and compilation time constraints. Further tuning may be required based on synthesis reports and target FPGA device characteristics.